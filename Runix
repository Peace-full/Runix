#!/usr/bin/env bash
# Universal Runix v2.0: Cross-Platform Smart File Runner
# Supports: Linux (Ubuntu/Debian/Fedora/Arch), Windows (Git Bash/WSL), Termux (Android)
# shellcheck disable=SC2155

# Strict error handling
set -euo pipefail

# Cleanup trap
cleanup() {
    local exit_code=$?
    # Add any cleanup operations here
    [[ -n "${TEMP_FILES:-}" ]] && rm -f "${TEMP_FILES[@]}" 2>/dev/null || true
    exit "$exit_code"
}
trap cleanup EXIT INT TERM

# Platform Detection
detect_platform() {
    if [[ -d "/data/data/com.termux" ]]; then
        PLATFORM="termux"
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        PLATFORM="linux"
    elif [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]] || [[ -n "${WSLENV:-}" ]] || [[ "$(uname -s 2>/dev/null || echo "")" == MINGW* ]]; then
        PLATFORM="windows"
    else
        PLATFORM="unknown"
    fi
}
detect_platform

# Colors (with fallback for non-interactive terminals)
if [[ -t 1 ]] && command -v tput >/dev/null 2>&1 && tput colors >/dev/null 2>&1; then
    RED='\033[0;31m'
    GRN='\033[0;32m'
    YEL='\033[1;33m'
    BLU='\033[0;34m'
    CYAN='\033[1;36m'
    NC='\033[0m'
else
    RED='' GRN='' YEL='' BLU='' CYAN='' NC=''
fi

# Platform-specific paths
setup_paths() {
    case "$PLATFORM" in
        termux)
            RUNIX_DIR="${HOME}/Runix"
            DEFAULT_USER_FOLDER="${HOME}"
            BIN_INSTALL_DIR="${PREFIX}/bin"
            ;;
        linux)
            RUNIX_DIR="${HOME}/.runix"
            DEFAULT_USER_FOLDER="${HOME}"
            BIN_INSTALL_DIR="${HOME}/.local/bin"
            ;;
        windows)
            RUNIX_DIR="${HOME}/Runix"
            DEFAULT_USER_FOLDER="${HOME}"
            BIN_INSTALL_DIR="${HOME}/bin"
            ;;
        *)
            echo -e "${RED}‚ùå Unsupported platform: $PLATFORM${NC}" >&2
            exit 1
            ;;
    esac

    CONFIG_FILE="${RUNIX_DIR}/config"
    SHORTCUT_FILE="${RUNIX_DIR}/shortcuts"
    BIN_DIR="${RUNIX_DIR}/bin"
    LOG_DIR="${RUNIX_DIR}/logs"
    PREVIEW_EXTENSIONS="txt log csv md json xml html"
    
    mkdir -p "$RUNIX_DIR" "$BIN_DIR" "$LOG_DIR" "$BIN_INSTALL_DIR" 2>/dev/null || true
}
setup_paths

# Logging
LOG_FILE="${LOG_DIR}/runix.log"
TEMP_FILES=()

log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') | $*" >> "$LOG_FILE" 2>/dev/null || true
}

# Error handler
error_exit() {
    local msg="${1:-Unknown error}"
    local code="${2:-1}"
    echo -e "${RED}‚ùå Error: $msg${NC}" >&2
    log "ERROR: $msg"
    exit "$code"
}

# Banner
show_banner() {
    echo -e "${GRN}
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïù
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ïî‚ïù
‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïó
‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù
${NC}${BLU}Universal Runix v2.0 ($PLATFORM)${NC}"
}
show_banner

# Cross-platform sed in-place edit
safe_sed_replace() {
    local pattern="$1"
    local file="$2"
    local tmpfile
    tmpfile="$(mktemp)" || return 1
    TEMP_FILES+=("$tmpfile")
    
    if sed "$pattern" "$file" > "$tmpfile" 2>/dev/null; then
        mv "$tmpfile" "$file" || return 1
        return 0
    else
        rm -f "$tmpfile" 2>/dev/null || true
        return 1
    fi
}

# Cross-platform realpath
get_realpath() {
    local path="$1"
    if command -v realpath >/dev/null 2>&1; then
        realpath "$path" 2>/dev/null || echo "$path"
    elif command -v readlink >/dev/null 2>&1; then
        readlink -f "$path" 2>/dev/null || echo "$path"
    else
        # Fallback for Windows
        (cd "$(dirname "$path")" 2>/dev/null && echo "$PWD/$(basename "$path")") || echo "$path"
    fi
}

# Package manager detection
get_package_manager() {
    case "$PLATFORM" in
        termux)
            echo "pkg"
            ;;
        linux)
            if command -v apt-get >/dev/null 2>&1; then
                echo "apt"
            elif command -v dnf >/dev/null 2>&1; then
                echo "dnf"
            elif command -v yum >/dev/null 2>&1; then
                echo "yum"
            elif command -v pacman >/dev/null 2>&1; then
                echo "pacman"
            elif command -v zypper >/dev/null 2>&1; then
                echo "zypper"
            else
                echo "unknown"
            fi
            ;;
        windows)
            if command -v choco >/dev/null 2>&1; then
                echo "choco"
            elif command -v scoop >/dev/null 2>&1; then
                echo "scoop"
            elif command -v winget >/dev/null 2>&1; then
                echo "winget"
            else
                echo "manual"
            fi
            ;;
    esac
}

# Interactive Setup
setup_config() {
    echo -e "${YEL}üîß Initial Runix setup...${NC}"
    
    # Create config atomically
    {
        echo "user_folder=${DEFAULT_USER_FOLDER}"
        echo "preview=ask"
        echo "save_binaries=no"
    } > "$CONFIG_FILE"

    echo -e "${YEL}üëÅÔ∏è  Choose preview mode:${NC}"
    echo -e "   ${GRN}[1]${NC} Always preview"
    echo -e "   ${GRN}[2]${NC} Never preview"
    echo -e "   ${GRN}[3]${NC} Ask every time (default)"
    
    read -r -t 30 CHOICE || CHOICE=3
    case "$CHOICE" in
        1) safe_sed_replace 's/^preview=.*/preview=auto/' "$CONFIG_FILE" ;;
        2) safe_sed_replace 's/^preview=.*/preview=never/' "$CONFIG_FILE" ;;
        *) ;; # Keep default
    esac

    echo -e "${BLU}üß± Save compiled binaries? (y/n, default: n): ${NC}"
    read -r -t 30 KEEP || KEEP="n"
    if [[ "${KEEP,,}" =~ ^y ]]; then
        safe_sed_replace 's/^save_binaries=.*/save_binaries=yes/' "$CONFIG_FILE"
    fi

    touch "$SHORTCUT_FILE"
    log "Initial setup completed for $PLATFORM"
}

# Load Config with defaults
load_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        setup_config
    fi
    
    USER_FOLDER=$(grep '^user_folder=' "$CONFIG_FILE" 2>/dev/null | cut -d= -f2- | head -n1 || echo "$DEFAULT_USER_FOLDER")
    PREVIEW_MODE=$(grep '^preview=' "$CONFIG_FILE" 2>/dev/null | cut -d= -f2- | head -n1 || echo "ask")
    SAVE_BINARIES=$(grep '^save_binaries=' "$CONFIG_FILE" 2>/dev/null | cut -d= -f2- | head -n1 || echo "no")
    
    # Validate and set defaults
    USER_FOLDER="${USER_FOLDER:-$DEFAULT_USER_FOLDER}"
    PREVIEW_MODE="${PREVIEW_MODE:-ask}"
    SAVE_BINARIES="${SAVE_BINARIES:-no}"
}
load_config

# Shortcuts with validation
expand_shortcut() {
    local key="$1"
    if [[ -f "$SHORTCUT_FILE" ]] && grep -q "^${key}=" "$SHORTCUT_FILE" 2>/dev/null; then
        grep "^${key}=" "$SHORTCUT_FILE" 2>/dev/null | head -n1 | cut -d= -f2- || echo "$key"
    else
        echo "$key"
    fi
}

# Platform-specific package mapping
get_platform_package() {
    local generic_name="$1"
    
    case "${PLATFORM}:${generic_name}" in
        termux:gcc|termux:clang|termux:g++|termux:clang++) echo "clang" ;;
        termux:python3|termux:python) echo "python" ;;
        termux:java|termux:javac) echo "openjdk-17" ;;
        linux:gcc) echo "gcc" ;;
        linux:g++) echo "g++" ;;
        linux:python3|linux:python) echo "python3" ;;
        linux:java|linux:javac) echo "default-jdk" ;;
        linux:node) echo "nodejs" ;;
        linux:rustc) echo "cargo" ;;
        linux:go) echo "golang" ;;
        windows:gcc|windows:g++) echo "mingw" ;;
        windows:python3|windows:python) echo "python" ;;
        windows:java|windows:javac) echo "openjdk" ;;
        windows:node) echo "nodejs" ;;
        windows:rustc) echo "rust" ;;
        windows:go) echo "golang" ;;
        *) echo "$generic_name" ;;
    esac
}

# Dependency check with installation
need_pkg() {
    local cmd="$1"
    local generic_pkg="$2"
    
    if command -v "$cmd" >/dev/null 2>&1; then
        return 0
    fi
    
    local platform_pkg
    platform_pkg=$(get_platform_package "$generic_pkg")
    
    echo -e "${RED}‚ùå Missing: $cmd${NC}"
    echo -ne "${YEL}Install '$platform_pkg'? (y/n): ${NC}"
    read -r -t 30 ans || ans="n"
    
    if [[ "${ans,,}" =~ ^y ]]; then
        install_package "$platform_pkg" || return 1
        command -v "$cmd" >/dev/null 2>&1 || return 1
    else
        log "User declined to install: $cmd"
        return 1
    fi
}

install_package() {
    local pkg="$1"
    local pm
    pm=$(get_package_manager)
    
    echo -e "${YEL}üì¶ Installing $pkg via $pm...${NC}"
    
    case "$pm" in
        pkg) pkg install -y "$pkg" ;;
        apt) sudo apt-get update && sudo apt-get install -y "$pkg" ;;
        dnf|yum) sudo "$pm" install -y "$pkg" ;;
        pacman) sudo pacman -S --noconfirm "$pkg" ;;
        zypper) sudo zypper install -y "$pkg" ;;
        choco) choco install -y "$pkg" ;;
        scoop) scoop install "$pkg" ;;
        winget) winget install "$pkg" ;;
        manual|*)
            echo -e "${YEL}üì¶ Manual installation required${NC}"
            echo -e "Search: https://www.google.com/search?q=install+${pkg}+${PLATFORM}"
            return 1
            ;;
    esac
}

# File search with depth limit
find_file() {
    local fname="$1"
    local found_files=()
    local max_depth=10
    
    # Use find with depth limit to avoid deep recursion
    while IFS= read -r file; do
        found_files+=("$file")
        [[ ${#found_files[@]} -ge 50 ]] && break
    done < <(find "$USER_FOLDER" -maxdepth "$max_depth" -type f -name "*${fname}*" 2>/dev/null | head -n 50)
    
    # Fallback if find fails
    if [[ ${#found_files[@]} -eq 0 ]]; then
        while IFS= read -r file; do
            found_files+=("$file")
            [[ ${#found_files[@]} -ge 50 ]] && break
        done < <(find "$USER_FOLDER" -type f 2>/dev/null | grep -i "$fname" | head -n 50)
    fi
    
    case ${#found_files[@]} in
        0) return 1 ;;
        1) echo "${found_files[0]}" ;;
        *)
            if command -v fzf >/dev/null 2>&1; then
                printf '%s\n' "${found_files[@]}" | fzf --prompt="Select file: " --height 20
            else
                echo -e "${YEL}üìù Multiple files found:${NC}" >&2
                local i=1
                for file in "${found_files[@]}"; do
                    echo -e "${GRN}[$i]${NC} $file" >&2
                    ((i++))
                done
                echo -ne "${BLU}Select [1-${#found_files[@]}]: ${NC}" >&2
                read -r -t 30 choice || choice=1
                if [[ "$choice" =~ ^[0-9]+$ ]] && ((choice >= 1 && choice <= ${#found_files[@]})); then
                    echo "${found_files[$((choice-1))]}"
                else
                    echo "${found_files[0]}"
                fi
            fi
            ;;
    esac
}

# Java main class finder (robust)
find_java_main_class() {
    local file="$1"
    local class_name=""
    local has_main=0
    
    while IFS= read -r line; do
        if [[ "$line" =~ public[[:space:]]+class[[:space:]]+([A-Za-z0-9_]+) ]]; then
            class_name="${BASH_REMATCH[1]}"
        fi
        if [[ "$line" =~ public[[:space:]]+static[[:space:]]+void[[:space:]]+main ]]; then
            has_main=1
        fi
        if [[ -n "$class_name" ]] && [[ $has_main -eq 1 ]]; then
            echo "$class_name"
            return 0
        fi
    done < "$file"
    
    [[ -n "$class_name" ]] && echo "$class_name" && return 0
    return 1
}

# Show info
show_info() {
    echo -e "${YEL}üîß Runix Configuration:${NC}"
    echo "‚Ä¢ Platform        : $PLATFORM"
    echo "‚Ä¢ User folder     : $USER_FOLDER"
    echo "‚Ä¢ Preview mode    : $PREVIEW_MODE"
    echo "‚Ä¢ Save binaries   : $SAVE_BINARIES"
    echo "‚Ä¢ Config file     : $CONFIG_FILE"
    echo "‚Ä¢ Shortcut file   : $SHORTCUT_FILE"
    echo "‚Ä¢ Binary dir      : $BIN_DIR"
    echo "‚Ä¢ Package manager : $(get_package_manager)"
}

# Compile function with proper error handling
compile() {
    local ext="$1"
    local file="$2"
    local out="$3"
    
    echo -e "${YEL}üî® Compiling...${NC}"
    
    case "$ext" in
        c)
            if need_pkg gcc gcc || need_pkg clang clang; then
                local compiler
                compiler=$(command -v gcc || command -v clang)
                "$compiler" -fsyntax-only "$file" || return 1
                "$compiler" "$file" -o "$out" || return 1
            else
                return 1
            fi
            ;;
        cpp|cc|cxx)
            if need_pkg g++ g++ || need_pkg clang++ clang++; then
                local compiler
                compiler=$(command -v g++ || command -v clang++)
                "$compiler" -fsyntax-only "$file" || return 1
                "$compiler" "$file" -o "$out" || return 1
            else
                return 1
            fi
            ;;
        py)
            if need_pkg python3 python3 || need_pkg python python; then
                local python_cmd
                python_cmd=$(command -v python3 || command -v python)
                "$python_cmd" -m py_compile "$file" || return 1
            else
                return 1
            fi
            ;;
        java)
            need_pkg javac javac || return 1
            javac "$file" -d "$BIN_DIR" || return 1
            # Verify class file was created
            local class_name
            class_name=$(find_java_main_class "$file")
            [[ -f "${BIN_DIR}/${class_name}.class" ]] || return 1
            ;;
        js)
            need_pkg node node || return 1
            ;;
        sh)
            bash -n "$file" || return 1
            ;;
        rs)
            need_pkg rustc rustc || return 1
            rustc "$file" -o "$out" || return 1
            ;;
        go)
            need_pkg go go || return 1
            go build -o "$out" "$file" || return 1
            ;;
        php)
            need_pkg php php || return 1
            php -l "$file" >/dev/null || return 1
            ;;
        rb)
            need_pkg ruby ruby || return 1
            ruby -c "$file" >/dev/null || return 1
            ;;
        *)
            echo -e "${RED}‚ùå Unknown extension: $ext${NC}" >&2
            return 1
            ;;
    esac
    
    echo -e "${GRN}‚úÖ Compiled successfully${NC}"
    return 0
}

# Execute function
execute() {
    local ext="$1"
    local file="$2"
    local out="$3"
    
    echo -e "${YEL}‚ñ∂Ô∏è  Executing...${NC}"
    
    case "$ext" in
        c|cpp|cc|cxx|rs|go)
            if [[ ! -f "$out" ]]; then
                echo -e "${RED}‚ùå Binary not found: $out${NC}" >&2
                return 1
            fi
            [[ "$PLATFORM" != "windows" ]] && chmod +x "$out" 2>/dev/null || true
            "$out"
            ;;
        py)
            local python_cmd
            python_cmd=$(command -v python3 || command -v python)
            need_pkg "$python_cmd" python3 || return 1
            "$python_cmd" "$file"
            ;;
        java)
            need_pkg java java || return 1
            local main_class
            main_class=$(find_java_main_class "$file") || {
                echo -e "${RED}‚ùå No main class found${NC}" >&2
                return 1
            }
            java -cp "$BIN_DIR" "$main_class"
            ;;
        js)
            need_pkg node node || return 1
            node "$file"
            ;;
        sh) bash "$file" ;;
        php)
            need_pkg php php || return 1
            php "$file"
            ;;
        rb)
            need_pkg ruby ruby || return 1
            ruby "$file"
            ;;
        *)
            echo -e "${RED}‚ùå Unknown extension: $ext${NC}" >&2
            return 1
            ;;
    esac
}

# Main run function
run_file() {
    local input="$1"
    local mode="${2:-cr}"
    
    input=$(expand_shortcut "$input")
    
    local file
    file=$(find_file "$input") || {
        echo -e "${RED}‚ùå File not found: $input${NC}" >&2
        log "File not found: $input"
        return 1
    }

    [[ ! -f "$file" ]] && error_exit "Not a file: $file"

    local ext="${file##*.}"
    local base="${file%.*}"
    local out="${BIN_DIR}/$(basename "$base")"
    
    # Platform-specific binary extension
    if [[ "$PLATFORM" == "windows" ]]; then
        case "$ext" in
            c|cpp|cc|cxx|rs|go) out="${out}.exe" ;;
        esac
    fi

    echo -e "${BLU}üìÅ File: $file${NC}"
    
    # Save and change directory
    local original_dir="$PWD"
    cd "$(dirname "$file")" || error_exit "Cannot access directory: $(dirname "$file")"

    local start_time
    start_time=$(date +%s)
    local result=0

    case "${mode,,}" in
        c)
            compile "$ext" "$file" "$out" || result=$?
            ;;
        r)
            execute "$ext" "$file" "$out" || result=$?
            ;;
        cr|rc|"")
            if compile "$ext" "$file" "$out"; then
                execute "$ext" "$file" "$out" || result=$?
            else
                result=$?
            fi
            ;;
        *)
            echo -e "${RED}‚ùå Unknown mode: $mode${NC}" >&2
            cd "$original_dir"
            return 1
            ;;
    esac

    local end_time
    end_time=$(date +%s)
    echo -e "${YEL}‚è±Ô∏è  Time: $((end_time - start_time))s${NC}"

    # Preview output files
    local preview_files=()
    for pext in $PREVIEW_EXTENSIONS; do
        while IFS= read -r -d '' f; do
            preview_files+=("$f")
        done < <(find . -maxdepth 1 -type f -name "*.${pext}" -print0 2>/dev/null)
    done

    if [[ ${#preview_files[@]} -gt 0 ]]; then
        local do_preview="n"
        case "$PREVIEW_MODE" in
            auto) do_preview="y" ;;
            never) do_preview="n" ;;
            *)
                echo -ne "${BLU}üëÅÔ∏è  View output files? (y/n): ${NC}"
                read -r -t 30 do_preview || do_preview="n"
                ;;
        esac
        
        if [[ "${do_preview,,}" =~ ^y ]]; then
            for f in "${preview_files[@]}"; do
                echo -e "\n${CYAN}=== $(basename "$f") ===${NC}"
                if command -v bat >/dev/null 2>&1; then
                    bat "$f" 2>/dev/null || cat "$f"
                elif command -v pygmentize >/dev/null 2>&1; then
                    pygmentize "$f" 2>/dev/null || cat "$f"
                else
                    cat "$f"
                fi
            done
        fi
    fi

    # Cleanup
    if [[ "$SAVE_BINARIES" != "yes" ]] && [[ -f "$out" ]]; then
        rm -f "$out" 2>/dev/null || true
    fi

    cd "$original_dir"
    return "$result"
}

# Clean compiled files
clean_bin() {
    echo -e "${YEL}üßπ Cleaning...${NC}"
    
    [[ -d "$BIN_DIR" ]] && find "$BIN_DIR" -type f -delete 2>/dev/null || true
    find "$USER_FOLDER" -maxdepth 5 -type f -name "*.pyc" -delete 2>/dev/null || true
    find "$USER_FOLDER" -maxdepth 5 -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
    
    echo -e "${GRN}‚úÖ Cleaned${NC}"
    log "Cleaned compiled files"
}

# Run all files
run_all() {
    echo -e "${YEL}üöÄ Running all files...${NC}"
    local count=0 failed=0
    
    while IFS= read -r file; do
        case "$file" in
            *.c|*.cpp|*.cc|*.cxx|*.py|*.java|*.js|*.sh|*.rs|*.go|*.php|*.rb)
                echo -e "\n${CYAN}>>> $(basename "$file")${NC}"
                if run_file "$(basename "$file")" ""; then
                    ((count++))
                else
                    ((failed++))
                fi
                ;;
        esac
    done < <(find "$USER_FOLDER" -maxdepth 5 -type f 2>/dev/null)
    
    echo -e "\n${GRN}‚úÖ Success: $count${NC}"
    [[ $failed -gt 0 ]] && echo -e "${RED}‚ùå Failed: $failed${NC}"
}

# Search files
search_file() {
    echo -ne "${BLU}üîç Search term: ${NC}"
    read -r -t 60 name || return
    
    [[ -z "$name" ]] && echo -e "${YEL}Empty search${NC}" && return
    
    echo -e "${YEL}üîé Searching...${NC}"
    local found=0
    
    while IFS= read -r f; do
        local size
        size=$(du -h "$f" 2>/dev/null | cut -f1 || echo "?")
        local ftype
        ftype=$(file -b "$f" 2>/dev/null || echo "unknown")
        echo -e "${GRN}‚Ä¢ $(basename "$f")${NC}"
        echo "  Type: $ftype | Size: $size"
        echo "  Path: $f"
        found=1
    done < <(find "$USER_FOLDER" -maxdepth 10 -type f -name "*${name}*" 2>/dev/null | head -n 20)
    
    [[ $found -eq 0 ]] && echo -e "${YEL}No matches${NC}"
}

# Change settings
change_settings() {
    echo -e "${YEL}‚öôÔ∏è  Settings${NC}\n"
    
    echo -ne "${BLU}üìÅ User folder [${USER_FOLDER}]: ${NC}"
    read -r -t 60 folder || folder=""
    if [[ -n "$folder" ]] && [[ -d "$folder" ]]; then
        USER_FOLDER="$folder"
    elif [[ -n "$folder" ]]; then
        echo -e "${YEL}‚ö†Ô∏è  Directory not found${NC}"
    fi
    
    echo -e "\n${YEL}üëÅÔ∏è  Preview:${NC}"
    echo -e "   ${GRN}[1]${NC} Always"
    echo -e "   ${GRN}[2]${NC} Never"
    echo -e "   ${GRN}[3]${NC} Ask"
    read -r -t 30 choice || choice=""
    case "$choice" in
        1) PREVIEW_MODE="auto" ;;
        2) PREVIEW_MODE="never" ;;
        3) PREVIEW_MODE="ask" ;;
    esac

    echo -ne "\n${BLU}üß± Save binaries? (y/n) [${SAVE_BINARIES}]: ${NC}"
    read -r -t 30 keep || keep=""
    case "${keep,,}" in
        y) SAVE_BINARIES="yes" ;;
        n) SAVE_BINARIES="no" ;;
    esac
    
    # Write config atomically
    {
        echo "user_folder=${USER_FOLDER}"
        echo "preview=${PREVIEW_MODE}"
        echo "save_binaries=${SAVE_BINARIES}"
    } > "$CONFIG_FILE"
    
    echo -e "\n${GRN}‚úÖ Saved${NC}"
    log "Settings updated"
}

# Add shortcut
add_shortcut() {
    echo -ne "${BLU}üîë Shortcut name: ${NC}"
    read -r -t 60 key || return
    [[ -z "$key" ]] && echo -e "${YEL}Empty name${NC}" && return
    
    echo -ne "${BLU}üìÑ Target file/command: ${NC}"
    read -r -t 60 val || return
    [[ -z "$val" ]] && echo -e "${YEL}Empty value${NC}" && return
    
    if grep -q "^${key}=" "$SHORTCUT_FILE" 2>/dev/null; then
        echo -ne "${YEL}‚ö†Ô∏è  Overwrite existing? (y/n): ${NC}"
        read -r -t 30 ans || ans="n"
        [[ ! "${ans,,}" =~ ^y ]] && echo "Cancelled" && return
        safe_sed_replace "/^${key}=/d" "$SHORTCUT_FILE"
    fi
    
    echo "${key}=${val}" >> "$SHORTCUT_FILE"
    echo -e "${GRN}‚úÖ Shortcut added: runix ${key} ‚Üí ${val}${NC}"
    log "Added shortcut: $key -> $val"
}

# List shortcuts
list_shortcuts() {
    echo -e "${YEL}üìù Shortcuts:${NC}"
    if [[ ! -f "$SHORTCUT_FILE" ]] || [[ ! -s "$SHORTCUT_FILE" ]]; then
        echo -e "${YEL}None defined${NC}"
        return
    fi
    
    while IFS='=' read -r key val; do
        [[ -z "$key" ]] && continue
        echo -e "  ${GRN}${key}${NC} ‚Üí ${val}"
    done < "$SHORTCUT_FILE"
}

# Help
show_help() {
    cat << EOF
${YEL}üìò Runix Commands:${NC}

${CYAN}Running Files:${NC}
  runix file.ext         ‚ñ∂Ô∏è  Compile & run
  runix file.ext c       üî® Compile only
  runix file.ext r       ‚ñ∂Ô∏è  Run only

${CYAN}Batch Operations:${NC}
  runix runall           üöÄ Run all files
  runix clean            üßπ Clear binaries

${CYAN}File Management:${NC}
  runix search           üîç Search files

${CYAN}Configuration:${NC}
  runix settings         ‚öôÔ∏è  Change settings
  runix info             ‚ÑπÔ∏è  Show config

${CYAN}Shortcuts:${NC}
  runix shortcut         ‚ûï Add shortcut
  runix shortcuts        üìù List shortcuts

${CYAN}System:${NC}
  runix install          üì¶ Install globally
  runix uninstall        üóëÔ∏è  Remove Runix
  runix logs             üìã Show logs
  runix version          üîñ Version info
  runix help             ‚ùì This help

${YEL}Supported Languages:${NC}
  C, C++, Python, Java, JavaScript, Shell, Rust, Go, PHP, Ruby

${YEL}Examples:${NC}
  runix hello.c          # Compile and run
  runix script.py        # Run Python
  runix app.java c       # Compile only
  runix hw               # Use shortcut
EOF
}

# Show logs
show_logs() {
    echo -e "${YEL}üìã Recent logs:${NC}"
    if [[ -f "$LOG_FILE" ]] && [[ -s "$LOG_FILE" ]]; then
        tail -n 20 "$LOG_FILE"
    else
        echo -e "${YEL}No logs found${NC}"
    fi
}

# Version info
show_version() {
    cat << EOF
${CYAN}Universal Runix v2.0${NC}
Platform: $PLATFORM
Shell: ${BASH_VERSION}
Package Manager: $(get_package_manager)
Config: $CONFIG_FILE
EOF
}

# Install globally
install_command() {
    echo -e "${YEL}üîß Installing runix...${NC}"
    
    local script_path
    script_path=$(get_realpath "$0")
    
    [[ -z "$script_path" ]] || [[ ! -f "$script_path" ]] && error_exit "Cannot find script"
    
    local install_path="${BIN_INSTALL_DIR}/runix"
    
    mkdir -p "$BIN_INSTALL_DIR" 2>/dev/null || true
    
    # Try symlink first
    if [[ "$PLATFORM" != "windows" ]] && ln -sf "$script_path" "$install_path" 2>/dev/null; then
        chmod +x "$install_path" 2>/dev/null || true
        echo -e "${GRN}‚úÖ Installed (symlink): $install_path${NC}"
    else
        # Fallback to copy
        if cp "$script_path" "$install_path" 2>/dev/null; then
            chmod +x "$install_path" 2>/dev/null || true
            echo -e "${GRN}‚úÖ Installed (copy): $install_path${NC}"
        else
            error_exit "Installation failed"
        fi
    fi
    
    # Check PATH
    if [[ ":$PATH:" != *":$BIN_INSTALL_DIR:"* ]]; then
        echo -e "\n${YEL}‚ö†Ô∏è  Add to PATH:${NC}"
        echo -e "${CYAN}export PATH=\"\$PATH:$BIN_INSTALL_DIR\"${NC}"
        echo -e "Add to ~/.bashrc or ~/.zshrc, then: ${CYAN}source ~/.bashrc${NC}"
    else
        echo -e "${GRN}‚úÖ PATH already configured${NC}"
    fi
    
    log "Installed runix command"
}

# Uninstall
uninstall_runix() {
    cat << EOF
${RED}‚ö†Ô∏è  This will remove:${NC}
  ‚Ä¢ Configuration: $RUNIX_DIR
  ‚Ä¢ All binaries
  ‚Ä¢ All shortcuts
  ‚Ä¢ The runix command

EOF
    echo -ne "${RED}Type 'yes' to confirm: ${NC}"
    read -r -t 30 confirm || confirm=""
    
    if [[ "$confirm" == "yes" ]]; then
        echo -e "${YEL}üßπ Uninstalling...${NC}"
        rm -f "${BIN_INSTALL_DIR}/runix" 2>/dev/null || true
        rm -rf "$RUNIX_DIR" 2>/dev/null || true
        echo -e "${GRN}‚úÖ Uninstalled${NC}"
        log "Uninstalled Runix"
        exit 0
    else
        echo -e "${YEL}Cancelled${NC}"
    fi
}

# Validate environment
validate_environment() {
    if [[ ! -d "$USER_FOLDER" ]]; then
        echo -e "${RED}‚ùå User folder not found: $USER_FOLDER${NC}" >&2
        echo -e "${YEL}Run: runix settings${NC}" >&2
        return 1
    fi
    
    if [[ ! -w "$RUNIX_DIR" ]]; then
        echo -e "${RED}‚ùå Cannot write to: $RUNIX_DIR${NC}" >&2
        return 1
    fi
    
    return 0
}

# Main function
main() {
    local cmd="${1:-}"
    local mode="${2:-}"
    
    # Convert to lowercase
    cmd="${cmd,,}"
    mode="${mode,,}"
    
    case "$cmd" in
        clean)
            clean_bin
            ;;
        runall)
            validate_environment && run_all
            ;;
        uninstall)
            uninstall_runix
            ;;
        settings|setup|config)
            change_settings
            ;;
        info)
            show_info
            ;;
        search|find)
            validate_environment && search_file
            ;;
        shortcut)
            add_shortcut
            ;;
        shortcuts|list)
            list_shortcuts
            ;;
        install)
            install_command
            ;;
        help|--help|-h)
            show_help
            ;;
        logs|last-error)
            show_logs
            ;;
        version|-v|--version)
            show_version
            ;;
        "")
            show_help
            ;;
        *)
            # Run file
            validate_environment && run_file "$1" "$mode"
            ;;
    esac
}

# Execute
main "$@"
