#!/usr/bin/env bash
# Runix: Smart Cross-Platform File Runner
# Supports: Linux, macOS, Windows (Git Bash/WSL), Android Termux

set -euo pipefail

# Detect OS
detect_os() {
    case "$(uname -s)" in
        Linux*)
            if [[ -d "/data/data/com.termux" ]]; then
                OS="termux"
            else
                OS="linux"
            fi
            ;;
        Darwin*) OS="macos" ;;
        MINGW*|MSYS*|CYGWIN*) OS="windows" ;;
        *) OS="unknown" ;;
    esac
}
detect_os

# Colors
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GRN='\033[0;32m'
    YEL='\033[1;33m'
    BLU='\033[0;34m'
    CYAN='\033[1;36m'
    MAG='\033[0;35m'
    NC='\033[0m'
else
    RED='' GRN='' YEL='' BLU='' CYAN='' MAG='' NC=''
fi

# OS-specific paths
setup_paths() {
    case "$OS" in
        termux)
            RUNIX_DIR="$HOME/Runix"
            DEFAULT_USER_FOLDER="/data/data/com.termux/files/home"
            PKG_MANAGER="pkg"
            ;;
        linux|macos)
            RUNIX_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/runix"
            DEFAULT_USER_FOLDER="$HOME"
            PKG_MANAGER=$(command -v apt-get || command -v yum || command -v brew || echo "none")
            ;;
        windows)
            RUNIX_DIR="$HOME/Runix"
            DEFAULT_USER_FOLDER="$HOME"
            PKG_MANAGER="choco"
            ;;
        *)
            echo -e "${RED}Unsupported OS${NC}"
            exit 1
            ;;
    esac

    CONFIG_FILE="$RUNIX_DIR/config"
    SHORTCUT_FILE="$RUNIX_DIR/shortcuts"
    BIN_DIR="$RUNIX_DIR/bin"
    LOG_DIR="$RUNIX_DIR/logs"
    HISTORY_FILE="$RUNIX_DIR/history"
    PREVIEW_EXTENSIONS="txt log csv md json xml html class"
    
    mkdir -p "$RUNIX_DIR" "$BIN_DIR" "$LOG_DIR"
}
setup_paths

# Logging
LOG_FILE="$LOG_DIR/runix_$(date +%Y%m%d).log"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$OS] $*" >> "$LOG_FILE"
}

# Banner
show_banner() {
    echo -e "${GRN}
██████╗ ██╗   ██╗███╗   ██╗██╗██╗  ██╗
██╔══██╗██║   ██║████╗  ██║██║╚██╗██╔╝
██████╔╝██║   ██║██╔██╗ ██║██║ ╚███╔╝
██╔══██╗██║   ██║██║╚██╗██║██║ ██╔██╗
██║  ██║╚██████╔╝██║ ╚████║██║██╔╝ ██╗
╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝╚═╝  ╚═╝
${NC}${BLU}Cross-Platform File Runner${NC} ${MAG}[$OS]${NC}"
}

# Interactive Setup
setup_config() {
    echo -e "${YEL}🔧 Initial Runix setup for $OS...${NC}"
    {
        echo "user_folder=$DEFAULT_USER_FOLDER"
        echo "os=$OS"
        echo "version=2.0"
    } > "$CONFIG_FILE"

    echo -e "${YEL}👁️ Choose preview mode:${NC}"
    echo -e "   ${GRN}[1]${NC} Always preview"
    echo -e "   ${GRN}[2]${NC} Never preview"
    echo -e "   ${GRN}[3]${NC} Ask every time"
    read -r CHOICE
    case "$CHOICE" in
        1) echo "preview=auto" >> "$CONFIG_FILE" ;;
        2) echo "preview=never" >> "$CONFIG_FILE" ;;
        *) echo "preview=ask" >> "$CONFIG_FILE" ;;
    esac

    echo -e "${BLU}🧱 Save compiled binaries after running? (y/n): ${NC}"
    read -r KEEP
    if [[ "$KEEP" =~ ^[yY]$ ]]; then
        echo "save_binaries=yes" >> "$CONFIG_FILE"
    else
        echo "save_binaries=no" >> "$CONFIG_FILE"
    fi

    echo -e "${BLU}📊 Enable execution statistics? (y/n): ${NC}"
    read -r STATS
    if [[ "$STATS" =~ ^[yY]$ ]]; then
        echo "show_stats=yes" >> "$CONFIG_FILE"
    else
        echo "show_stats=no" >> "$CONFIG_FILE"
    fi

    touch "$SHORTCUT_FILE" "$HISTORY_FILE"
    log "Initial setup completed"
}

# Load Config
load_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        setup_config
    fi
    
    USER_FOLDER=$(grep '^user_folder=' "$CONFIG_FILE" | cut -d= -f2-)
    PREVIEW_MODE=$(grep '^preview=' "$CONFIG_FILE" | cut -d= -f2-)
    SAVE_BINARIES=$(grep '^save_binaries=' "$CONFIG_FILE" | cut -d= -f2-)
    SHOW_STATS=$(grep '^show_stats=' "$CONFIG_FILE" | cut -d= -f2-)
    
    # Set defaults if missing
    USER_FOLDER="${USER_FOLDER:-$DEFAULT_USER_FOLDER}"
    PREVIEW_MODE="${PREVIEW_MODE:-ask}"
    SAVE_BINARIES="${SAVE_BINARIES:-no}"
    SHOW_STATS="${SHOW_STATS:-yes}"
}
load_config

# Shortcuts
expand_shortcut() {
    if grep -q "^$1=" "$SHORTCUT_FILE" 2>/dev/null; then
        grep "^$1=" "$SHORTCUT_FILE" | head -n1 | cut -d= -f2-
    else
        echo "$1"
    fi
}

# OS-specific package installation
install_package() {
    local pkg="$1"
    echo -e "${YEL}Installing $pkg for $OS...${NC}"
    
    case "$OS" in
        termux)
            pkg install -y "$pkg"
            ;;
        linux)
            if command -v apt-get >/dev/null 2>&1; then
                sudo apt-get install -y "$pkg"
            elif command -v yum >/dev/null 2>&1; then
                sudo yum install -y "$pkg"
            elif command -v dnf >/dev/null 2>&1; then
                sudo dnf install -y "$pkg"
            elif command -v pacman >/dev/null 2>&1; then
                sudo pacman -S --noconfirm "$pkg"
            else
                echo -e "${RED}No supported package manager found${NC}"
                return 1
            fi
            ;;
        macos)
            if command -v brew >/dev/null 2>&1; then
                brew install "$pkg"
            else
                echo -e "${RED}Homebrew not installed. Visit https://brew.sh${NC}"
                return 1
            fi
            ;;
        windows)
            if command -v choco >/dev/null 2>&1; then
                choco install -y "$pkg"
            else
                echo -e "${RED}Chocolatey not installed. Visit https://chocolatey.org${NC}"
                return 1
            fi
            ;;
    esac
}

# Dependency Check
need_pkg() {
    local cmd="$1"
    local pkg="${2:-$1}"
    
    if ! command -v "$cmd" >/dev/null 2>&1; then
        echo -e "${RED}❌ Missing '$cmd'${NC}"
        echo -ne "${YEL}Install '$pkg' now? (y/n): ${NC}"
        read -r ans
        if [[ "$ans" =~ ^[yY]$ ]]; then
            install_package "$pkg" || return 1
        else
            echo -e "${RED}Cannot continue without '$cmd'${NC}"
            log "Missing dependency: $cmd"
            return 1
        fi
    fi
    return 0
}

# File Search with OS-specific optimizations
find_file() {
    local fname="$1"
    local search_dir="${2:-$USER_FOLDER}"
    
    # Use fd if available (faster than find)
    if command -v fd >/dev/null 2>&1; then
        local results
        results=$(fd -t f -i "$fname" "$search_dir" 2>/dev/null)
    else
        local results
        results=$(find "$search_dir" -type f -iname "*$fname*" 2>/dev/null)
    fi
    
    if [[ -z "$results" ]]; then
        echo ""
        return 1
    fi
    
    # Use fzf for interactive selection if available
    if command -v fzf >/dev/null 2>&1 && [[ $(echo "$results" | wc -l) -gt 1 ]]; then
        echo "$results" | fzf --prompt="Choose file: " --height=20 --border
    else
        echo "$results" | head -n 1
    fi
}

# Java main class finder
find_java_main_class() {
    local file="$1"
    grep -E 'public\s+class\s+\w+' "$file" | \
        grep -B 2 'public\s+static\s+void\s+main' | \
        grep 'public\s+class' | \
        sed -E 's/.*public\s+class\s+([A-Za-z0-9_]+).*/\1/' | \
        head -n 1
}

# Show system info
show_info() {
    echo -e "${YEL}🔧 Runix Configuration:${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo "• Operating System : $OS"
    echo "• User folder      : $USER_FOLDER"
    echo "• Preview mode     : $PREVIEW_MODE"
    echo "• Save binaries    : $SAVE_BINARIES"
    echo "• Show statistics  : $SHOW_STATS"
    echo "• Config file      : $CONFIG_FILE"
    echo "• Binary directory : $BIN_DIR"
    echo "• Log directory    : $LOG_DIR"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    # OS-specific features
    case "$OS" in
        termux)
            echo -e "${MAG}Termux Features: Storage access, Termux-API support${NC}"
            ;;
        linux)
            echo -e "${MAG}Linux Features: System-wide installation, sudo support${NC}"
            ;;
        macos)
            echo -e "${MAG}macOS Features: Homebrew integration, Spotlight indexing${NC}"
            ;;
        windows)
            echo -e "${MAG}Windows Features: PowerShell integration, WSL support${NC}"
            ;;
    esac
}

# Compile with OS-specific optimizations
compile() {
    local ext="$1"
    local file="$2"
    local out="$3"
    
    echo -e "${YEL}⚙️  Compiling $file...${NC}"
    
    case "$ext" in
        c)
            need_pkg gcc gcc || need_pkg clang clang || return 1
            if command -v clang >/dev/null 2>&1; then
                clang -Wall -O2 "$file" -o "$out"
            else
                gcc -Wall -O2 "$file" -o "$out"
            fi
            ;;
        cpp|cc|cxx)
            need_pkg g++ g++ || need_pkg clang++ clang || return 1
            if command -v clang++ >/dev/null 2>&1; then
                clang++ -Wall -O2 -std=c++17 "$file" -o "$out"
            else
                g++ -Wall -O2 -std=c++17 "$file" -o "$out"
            fi
            ;;
        py)
            need_pkg python3 python3 || need_pkg python python || return 1
            python3 -m py_compile "$file" 2>/dev/null || python -m py_compile "$file"
            ;;
        java)
            need_pkg javac openjdk || return 1
            javac "$file" -d "$BIN_DIR"
            ;;
        js)
            need_pkg node nodejs || return 1
            # Syntax check
            node --check "$file"
            ;;
        ts)
            need_pkg tsc typescript || return 1
            tsc "$file" --outDir "$BIN_DIR"
            ;;
        rs)
            need_pkg rustc rust || return 1
            rustc -O "$file" -o "$out"
            ;;
        go)
            need_pkg go golang || return 1
            go build -o "$out" "$file"
            ;;
        cs)
            if [[ "$OS" == "windows" ]]; then
                need_pkg csc dotnet-sdk || return 1
                csc "/out:$out.exe" "$file"
            else
                need_pkg mcs mono || return 1
                mcs "$file" -out:"$out"
            fi
            ;;
        sh|bash)
            need_pkg bash bash || return 1
            bash -n "$file"  # Syntax check
            ;;
        php|rb|pl)
            ;; # Interpreted, no compilation
        *)
            echo -e "${RED}❌ Unsupported file extension: $ext${NC}"
            log "Unsupported extension: $ext"
            return 1
            ;;
    esac
    
    echo -e "${GRN}✅ Compilation successful${NC}"
    log "Compiled: $file"
    return 0
}

# Execute with OS-specific handling
execute() {
    local ext="$1"
    local file="$2"
    local out="$3"
    
    echo -e "${YEL}▶️  Executing $file...${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    case "$ext" in
        c|cpp|cc|cxx|rs|go)
            if [[ "$OS" == "windows" ]]; then
                "$out.exe"
            else
                "$out"
            fi
            ;;
        py)
            if command -v python3 >/dev/null 2>&1; then
                python3 "$file"
            else
                python "$file"
            fi
            ;;
        java)
            local main_class
            main_class=$(find_java_main_class "$file")
            if [[ -n "$main_class" ]]; then
                java -cp "$BIN_DIR" "$main_class"
            else
                echo -e "${RED}❌ No main class found${NC}"
                return 1
            fi
            ;;
        js)
            node "$file"
            ;;
        ts)
            local js_file="${file%.ts}.js"
            if [[ -f "$BIN_DIR/$js_file" ]]; then
                node "$BIN_DIR/$js_file"
            else
                need_pkg ts-node typescript || return 1
                ts-node "$file"
            fi
            ;;
        sh|bash)
            bash "$file"
            ;;
        php)
            need_pkg php php || return 1
            php "$file"
            ;;
        rb)
            need_pkg ruby ruby || return 1
            ruby "$file"
            ;;
        pl)
            need_pkg perl perl || return 1
            perl "$file"
            ;;
        cs)
            if [[ "$OS" == "windows" ]]; then
                "$out.exe"
            else
                mono "$out"
            fi
            ;;
        *)
            echo -e "${RED}❌ Unsupported execution for: $ext${NC}"
            return 1
            ;;
    esac
    
    local exit_code=$?
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    if [[ $exit_code -eq 0 ]]; then
        echo -e "${GRN}✅ Execution completed (exit code: $exit_code)${NC}"
    else
        echo -e "${RED}❌ Execution failed (exit code: $exit_code)${NC}"
    fi
    
    log "Executed: $file (exit: $exit_code)"
    return $exit_code
}

# Main run function
run_file() {
    local input="$1"
    local mode="${2:-}"
    
    input=$(expand_shortcut "$input")
    
    local file
    file=$(find_file "$input")
    
    if [[ -z "$file" ]]; then
        echo -e "${RED}❌ File not found: $input${NC}"
        log "File not found: $input"
        return 1
    fi

    local ext="${file##*.}"
    local base="${file%.*}"
    local out="$BIN_DIR/$(basename "$base")"

    echo -e "${BLU}📁 File: $file${NC}"
    echo -e "${BLU}📊 Size: $(du -h "$file" | cut -f1)${NC}"
    
    # Save to history
    echo "$(date '+%Y-%m-%d %H:%M:%S') | $file" >> "$HISTORY_FILE"
    
    # Change to file directory
    local file_dir
    file_dir=$(dirname "$file")
    pushd "$file_dir" > /dev/null || return 1

    # Start timing and memory tracking
    local start_time
    start_time=$(date +%s)
    local start_mem=0
    
    if [[ "$SHOW_STATS" == "yes" ]]; then
        if command -v ps >/dev/null 2>&1; then
            start_mem=$(ps -o rss= -p $$ 2>/dev/null || echo 0)
        fi
    fi

    # Execute based on mode
    case "$mode" in
        c|compile)
            compile "$ext" "$file" "$out"
            ;;
        r|run)
            execute "$ext" "$file" "$out"
            ;;
        *)
            compile "$ext" "$file" "$out" && execute "$ext" "$file" "$out"
            ;;
    esac
    
    local exit_code=$?

    # Calculate statistics
    if [[ "$SHOW_STATS" == "yes" ]]; then
        local end_time
        end_time=$(date +%s)
        local duration=$((end_time - start_time))
        
        local mem_used=0
        if command -v ps >/dev/null 2>&1; then
            local end_mem
            end_mem=$(ps -o rss= -p $$ 2>/dev/null || echo 0)
            mem_used=$((end_mem - start_mem))
        fi
        
        echo -e "${YEL}📊 Statistics:${NC}"
        echo -e "   ⏱️  Time: ${duration}s"
        if [[ $mem_used -gt 0 ]]; then
            echo -e "   🧠 Memory: ${mem_used}KB"
        fi
    fi

    # Preview output files
    preview_outputs

    # Cleanup
    if [[ "$SAVE_BINARIES" != "yes" && -f "$out" ]]; then
        rm -f "$out"
    fi
    
    popd > /dev/null
    return $exit_code
}

# Preview output files
preview_outputs() {
    local preview_files=()
    
    for ext in $PREVIEW_EXTENSIONS; do
        while IFS= read -r f; do
            [[ -f "$f" ]] && preview_files+=("$f")
        done < <(find . -maxdepth 1 -type f -name "*.$ext" 2>/dev/null)
    done

    if [[ ${#preview_files[@]} -gt 0 ]]; then
        local do_preview="n"
        
        case "$PREVIEW_MODE" in
            auto) do_preview="y" ;;
            never) do_preview="n" ;;
            *)
                echo -ne "${BLU}👁️  Preview ${#preview_files[@]} output file(s)? (y/n): ${NC}"
                read -r do_preview
                ;;
        esac
        
        if [[ "$do_preview" =~ ^[yY]$ ]]; then
            for f in "${preview_files[@]}"; do
                echo -e "${CYAN}━━━ $f ━━━${NC}"
                if command -v bat >/dev/null 2>&1; then
                    bat --style=plain --paging=never "$f"
                elif command -v pygmentize >/dev/null 2>&1; then
                    pygmentize "$f"
                else
                    head -n 50 "$f"
                fi
            done
        fi
    fi
}

# Clean compiled files
clean_bin() {
    echo -e "${YEL}🧹 Cleaning compiled files...${NC}"
    
    rm -rf "${BIN_DIR:?}"/*
    find "$USER_FOLDER" -type f \( -name "*.pyc" -o -name "*.class" -o -name "*.o" \
        -o -name "*.rlib" -o -name "*.rmeta" -o -name "*.a" \) -delete 2>/dev/null
    find "$USER_FOLDER" -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null
    
    echo -e "${GRN}✅ Cleanup complete${NC}"
    log "Cleaned compiled files"
}

# Run all files
run_all() {
    local count=0
    local success=0
    
    echo -e "${YEL}🚀 Running all supported files in $USER_FOLDER...${NC}"
    
    while IFS= read -r file; do
        case "$file" in
            *.c|*.cpp|*.cc|*.cxx|*.py|*.java|*.js|*.ts|*.sh|*.rs|*.go|*.php|*.rb|*.pl|*.cs)
                ((count++))
                echo -e "\n${CYAN}[$count] Processing: $file${NC}"
                if run_file "$(basename "$file")"; then
                    ((success++))
                fi
                ;;
        esac
    done < <(find "$USER_FOLDER" -type f 2>/dev/null)
    
    echo -e "\n${GRN}✅ Completed: $success/$count files successful${NC}"
}

# Search files
search_file() {
    echo -ne "${BLU}🔍 Filename to search: ${NC}"
    read -r name
    
    echo -e "${YEL}🔎 Searching in $USER_FOLDER...${NC}"
    
    local count=0
    while IFS= read -r f; do
        ((count++))
        local size type modified
        size=$(du -h "$f" 2>/dev/null | cut -f1)
        type=$(file -b "$f" 2>/dev/null || echo "Unknown")
        
        if [[ "$OS" == "macos" ]]; then
            modified=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$f" 2>/dev/null)
        else
            modified=$(stat -c "%y" "$f" 2>/dev/null | cut -d'.' -f1)
        fi
        
        echo -e "${GRN}[$count] $(basename "$f")${NC}"
        echo -e "    Type: $type | Size: $size | Modified: $modified"
        echo -e "    Path: $f"
    done < <(find "$USER_FOLDER" -type f -iname "*$name*" 2>/dev/null)
    
    if [[ $count -eq 0 ]]; then
        echo -e "${RED}No files found${NC}"
    fi
}

# Change settings
change_settings() {
    echo -e "${YEL}⚙️  Reconfigure Runix${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    echo -ne "${BLU}📁 User folder [$USER_FOLDER]: ${NC}"
    read -r folder
    [[ -n "$folder" ]] && USER_FOLDER="$folder"
    sed -i.bak '/^user_folder=/d' "$CONFIG_FILE"
    echo "user_folder=$USER_FOLDER" >> "$CONFIG_FILE"

    echo -e "${YEL}👁️  Preview mode:${NC}"
    echo -e "   ${GRN}[1]${NC} Always"
    echo -e "   ${GRN}[2]${NC} Never"
    echo -e "   ${GRN}[3]${NC} Ask"
    read -r choice
    sed -i.bak '/^preview=/d' "$CONFIG_FILE"
    case "$choice" in
        1) echo "preview=auto" >> "$CONFIG_FILE" ;;
        2) echo "preview=never" >> "$CONFIG_FILE" ;;
        *) echo "preview=ask" >> "$CONFIG_FILE" ;;
    esac

    echo -ne "${BLU}🧱 Save binaries? (y/n): ${NC}"
    read -r keep
    sed -i.bak '/^save_binaries=/d' "$CONFIG_FILE"
    [[ "$keep" =~ ^[yY]$ ]] && echo "save_binaries=yes" >> "$CONFIG_FILE" || echo "save_binaries=no" >> "$CONFIG_FILE"
    
    echo -ne "${BLU}📊 Show statistics? (y/n): ${NC}"
    read -r stats
    sed -i.bak '/^show_stats=/d' "$CONFIG_FILE"
    [[ "$stats" =~ ^[yY]$ ]] && echo "show_stats=yes" >> "$CONFIG_FILE" || echo "show_stats=no" >> "$CONFIG_FILE"
    
    rm -f "$CONFIG_FILE.bak"
    
    echo -e "${GRN}✅ Settings updated${NC}"
    load_config
}

# Add shortcut
add_shortcut() {
    echo -ne "${BLU}🔑 Shortcut name: ${NC}"
    read -r key
    echo -ne "${BLU}📄 Target file/command: ${NC}"
    read -r val
    
    echo "$key=$val" >> "$SHORTCUT_FILE"
    echo -e "${GRN}✅ Shortcut '$key' added${NC}"
    log "Added shortcut: $key=$val"
}

# List shortcuts
list_shortcuts() {
    if [[ -s "$SHORTCUT_FILE" ]]; then
        echo -e "${YEL}🔑 Configured Shortcuts:${NC}"
        while IFS='=' read -r key val; do
            echo -e "   ${GRN}$key${NC} → $val"
        done < "$SHORTCUT_FILE"
    else
        echo -e "${YEL}No shortcuts configured${NC}"
    fi
}

# Show history
show_history() {
    if [[ -s "$HISTORY_FILE" ]]; then
        echo -e "${YEL}📜 Recent Executions:${NC}"
        tail -n 20 "$HISTORY_FILE" | while IFS='|' read -r timestamp file; do
            echo -e "   ${CYAN}$timestamp${NC} → $file"
        done
    else
        echo -e "${YEL}No execution history${NC}"
    fi
}

# Show logs
show_logs() {
    if [[ -f "$LOG_FILE" ]]; then
        echo -e "${YEL}📋 Recent Logs:${NC}"
        tail -n 30 "$LOG_FILE"
    else
        echo -e "${YEL}No logs found${NC}"
    fi
}

# OS-specific features
os_features() {
    case "$OS" in
        termux)
            echo -e "${MAG}📱 Termux-specific features:${NC}"
            echo "  1. Setup storage access"
            echo "  2. Install Termux-API"
            echo "  3. Create desktop widget"
            read -r choice
            case "$choice" in
                1) termux-setup-storage ;;
                2) pkg install termux-api ;;
                3) echo -e "${YEL}Create widget manually via Termux:Widget app${NC}" ;;
            esac
            ;;
        linux)
            echo -e "${MAG}🐧 Linux-specific features:${NC}"
            echo "  1. Install as system command"
            echo "  2. Create desktop entry"
            read -r choice
            case "$choice" in
                1)
                    echo -e "${YEL}Creating system command...${NC}"
                    sudo cp "$0" /usr/local/bin/runix
                    sudo chmod +x /usr/local/bin/runix
                    echo -e "${GRN}✅ Installed to /usr/local/bin/runix${NC}"
                    ;;
                2)
                    echo -e "${YEL}Feature coming soon${NC}"
                    ;;
            esac
            ;;
        macos)
            echo -e "${MAG}🍎 macOS-specific features:${NC}"
            echo "  1. Add to PATH"
            echo "  2. Create Spotlight index"
            read -r choice
            case "$choice" in
                1)
                    echo "export PATH=\"\$PATH:$BIN_DIR\"" >> ~/.zshrc
                    echo -e "${GRN}✅ Added to ~/.zshrc${NC}"
                    ;;
                2)
                    mdimport -i "$RUNIX_DIR"
                    echo -e "${GRN}✅ Spotlight index created${NC}"
                    ;;
            esac
            ;;
        windows)
            echo -e "${MAG}🪟 Windows-specific features:${NC}"
            echo "  1. Add to PATH"
            echo "  2. Create PowerShell alias"
            echo "  3. WSL integration"
            read -r choice
            case "$choice" in
                1)
                    echo -e "${YEL}Add this to System Environment Variables:${NC}"
                    echo "$BIN_DIR"
                    ;;
                2)
                    local ps_profile="$HOME/Documents/PowerShell/Microsoft.PowerShell_profile.ps1"
                    mkdir -p "$(dirname "$ps_profile")"
                    echo "Set-Alias -Name runix -Value '$0'" >> "$ps_profile"
                    echo -e "${GRN}✅ PowerShell alias created${NC}"
                    ;;
                3)
                    if command -v wsl >/dev/null 2>&1; then
                        echo -e "${GRN}✅ WSL detected${NC}"
                        wsl -l -v
                    else
                        echo -e "${RED}WSL not installed${NC}"
                    fi
                    ;;
            esac
            ;;
    esac
}

# Benchmark mode
benchmark() {
    local file="$1"
    local iterations="${2:-5}"
    
    echo -e "${YEL}🏃 Benchmarking $file ($iterations iterations)...${NC}"
    
    local total_time=0
    local success_count=0
    
    for ((i=1; i<=iterations; i++)); do
        echo -e "${CYAN}Run $i/$iterations${NC}"
        local start
        start=$(date +%s)
        
        if run_file "$file" > /dev/null 2>&1; then
            ((success_count++))
        fi
        
        local end
        end=$(date +%s)
        local duration=$((end - start))
        total_time=$((total_time + duration))
        
        echo -e "   Time: ${duration}s"
    done
    
    local avg_time=$((total_time / iterations))
    
    echo -e "${GRN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${YEL}Benchmark Results:${NC}"
    echo -e "   Total time: ${total_time}s"
    echo -e "   Average time: ${avg_time}s"
    echo -e "   Success rate: $success_count/$iterations"
    echo -e "${GRN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

# Watch mode - auto-rerun on file changes
watch_mode() {
    local file="$1"
    
    if ! command -v inotifywait >/dev/null 2>&1 && ! command -v fswatch >/dev/null 2>&1; then
        echo -e "${RED}❌ Watch mode requires inotifywait (Linux) or fswatch (macOS)${NC}"
        return 1
    fi
    
    echo -e "${YEL}👁️  Watching $file for changes (Ctrl+C to stop)...${NC}"
    
    # Initial run
    run_file "$file"
    
    if command -v inotifywait >/dev/null 2>&1; then
        while inotifywait -e modify "$file" 2>/dev/null; do
            echo -e "${CYAN}━━━ File changed, rerunning... ━━━${NC}"
            run_file "$file"
        done
    else
        fswatch -o "$file" | while read -r; do
            echo -e "${CYAN}━━━ File changed, rerunning... ━━━${NC}"
            run_file "$file"
        done
    fi
}

# Interactive mode
interactive_mode() {
    echo -e "${YEL}🎮 Interactive Mode (type 'exit' to quit)${NC}"
    
    while true; do
        echo -ne "${BLU}runix> ${NC}"
        read -r input
        
        case "$input" in
            exit|quit|q) break ;;
            "") continue ;;
            *)
                eval "run_file $input" || true
                ;;
        esac
    done
}

# Export project
export_project() {
    echo -ne "${BLU}📦 Project name: ${NC}"
    read -r project_name
    
    local export_dir="$HOME/runix_export_${project_name}_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$export_dir"
    
    echo -e "${YEL}Exporting project to $export_dir...${NC}"
    
    # Copy binaries
    cp -r "$BIN_DIR"/* "$export_dir/" 2>/dev/null || true
    
    # Create README
    cat > "$export_dir/README.md" << EOF
# $project_name

Exported from Runix on $(date)

## System Information
- OS: $OS
- User folder: $USER_FOLDER

## Files Included
$(ls -1 "$export_dir")

## Execution History
$(tail -n 10 "$HISTORY_FILE" 2>/dev/null || echo "No history available")
EOF
    
    echo -e "${GRN}✅ Project exported to $export_dir${NC}"
}

# Update Runix
update_runix() {
    echo -e "${YEL}🔄 Updating Runix...${NC}"
    
    local update_url="https://raw.githubusercontent.com/Peace-forever69/Runix/main/Runix"
    local backup_file="$0.backup"
    
    # Create backup
    cp "$0" "$backup_file"
    
    if command -v curl >/dev/null 2>&1; then
        if curl -fsSL "$update_url" -o "$0"; then
            chmod +x "$0"
            echo -e "${GRN}✅ Updated successfully${NC}"
            rm -f "$backup_file"
        else
            echo -e "${RED}❌ Update failed, restoring backup${NC}"
            mv "$backup_file" "$0"
        fi
    elif command -v wget >/dev/null 2>&1; then
        if wget -q "$update_url" -O "$0"; then
            chmod +x "$0"
            echo -e "${GRN}✅ Updated successfully${NC}"
            rm -f "$backup_file"
        else
            echo -e "${RED}❌ Update failed, restoring backup${NC}"
            mv "$backup_file" "$0"
        fi
    else
        echo -e "${RED}❌ curl or wget required for updates${NC}"
        rm -f "$backup_file"
    fi
}

# Uninstall
uninstall_runix() {
    echo -e "${RED}⚠️  Uninstall Runix? This will remove all data. (y/n): ${NC}"
    read -r confirm
    
    if [[ "$confirm" =~ ^[yY]$ ]]; then
        echo -e "${YEL}Uninstalling...${NC}"
        
        # Remove system installations
        case "$OS" in
            linux)
                sudo rm -f /usr/local/bin/runix 2>/dev/null
                ;;
            macos)
                rm -f /usr/local/bin/runix 2>/dev/null
                ;;
        esac
        
        # Remove directories
        rm -rf "$RUNIX_DIR"
        
        # Remove from shell configs
        sed -i.bak '/runix/d' ~/.bashrc 2>/dev/null
        sed -i.bak '/runix/d' ~/.zshrc 2>/dev/null
        
        echo -e "${GRN}✅ Uninstalled successfully${NC}"
        log "Runix uninstalled"
    else
        echo -e "${YEL}Cancelled${NC}"
    fi
}

# Show help
show_help() {
    cat << EOF
${YEL}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}
${GRN}📘 RUNIX - Cross-Platform File Runner${NC}
${YEL}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}

${CYAN}Basic Commands:${NC}
  run <file>              Compile and execute file
  run <file> c            Compile only
  run <file> r            Run only (skip compilation)
  
${CYAN}File Management:${NC}
  run search              Search for files
  run clean               Remove compiled binaries
  run runall              Execute all supported files
  run history             Show execution history
  
${CYAN}Configuration:${NC}
  run settings            Change configuration
  run info                Show current settings
  run shortcuts           List all shortcuts
  run shortcut            Add new shortcut
  
${CYAN}Advanced Features:${NC}
  run watch <file>        Auto-rerun on file changes
  run benchmark <file>    Benchmark file execution
  run interactive         Enter interactive mode
  run export              Export project
  
${CYAN}OS-Specific:${NC}
  run os-features         Platform-specific features
  
${CYAN}System:${NC}
  run logs                Show recent logs
  run update              Update Runix
  run uninstall           Remove Runix
  run help                Show this help

${CYAN}Supported Languages:${NC}
  C, C++, Python, Java, JavaScript, TypeScript, Rust,
  Go, C#, Shell, PHP, Ruby, Perl

${YEL}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}
${MAG}Running on: $OS${NC}
${YEL}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}
EOF
}

# Main command dispatcher
main() {
    show_banner
    
    local command="${1,,}"
    shift || true
    
    case "$command" in
        # Basic operations
        c|compile)
            run_file "$1" "c"
            ;;
        r|run)
            run_file "$1" "r"
            ;;
        
        # File management
        clean)
            clean_bin
            ;;
        runall)
            run_all
            ;;
        search)
            search_file
            ;;
        history)
            show_history
            ;;
        
        # Configuration
        settings|setup|config)
            change_settings
            ;;
        info)
            show_info
            ;;
        shortcuts)
            list_shortcuts
            ;;
        shortcut|add-shortcut)
            add_shortcut
            ;;
        
        # Advanced features
        watch)
            watch_mode "$1"
            ;;
        benchmark|bench)
            benchmark "$1" "${2:-5}"
            ;;
        interactive|i)
            interactive_mode
            ;;
        export)
            export_project
            ;;
        
        # OS-specific
        os-features|osf)
            os_features
            ;;
        
        # System
        logs|log)
            show_logs
            ;;
        update)
            update_runix
            ;;
        uninstall)
            uninstall_runix
            ;;
        help|--help|-h|"")
            show_help
            ;;
        
        # Default: run file
        *)
            run_file "$command" "$1"
            ;;
    esac
}

# Execute main function
main "$@"
